/**
 * @Auther: ken.wangTJ
 * @Date: 3/20/2019 15:16
 * @Description:
 */
package cn.thinking.design.pattern.chapter11_Proxy;

/**
 * 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
 * 
 * 意图：为其他对象提供一种代理以控制对这个对象的访问。
 * 
 * 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，
 * 	或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
 * 
 * 应用实例： 1、Windows 里面的快捷方式。 2、买火车票不一定在火车站买，也可以去代售点。
 * 
 * 优点： 1、职责清晰。 2、高扩展性。 3、智能化。
 * 
 * 缺点：
 *  1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
 * 	2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
 * 
 * 使用场景：按职责来划分，通常有以下使用场景： 
 * 		1、远程代理。 （rmi reference: module of thinking-common； package:cn.thinking.rmi）
 * 		2、虚拟代理。
 * 			 如果使用过Hibernate,或者动态代理，客户端实际获得的是一个虚拟代理，比如一个类中有一个Collection，只有当我们访问这个Collection时，
 * 			Hibernate才会从数据库中装载这些Collection数据。
 * 		3、Copy-on-Write 代理。 
 * 			copy-on-write只有客户端对这个虚拟代理进行修改时，代理才会立即从原始对象拷贝真正数据过来，这些动作都是在侦察到修改动作时，悄悄发生的。
 * 		4、保护（Protect or Access）代理。 
 * 		5、Cache代理。 
 * 		6、防火墙（Firewall）代理。 
 * 		7、同步化（Synchronization）代理。 
 * 		8、智能引用（Smart Reference）代理。
 * 
 * 注意事项： 
 * 	1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
 * 	2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
 *
 */